Documentation go : zeal



--------------------------------------------------------------------------------------------
                    chal 1

Base64 to hex 
test
    verifier la chaine avec la 2eme chaine donnée

--------------------------------------------------------------------------------------------
                    chal 2

xor 2 chaines (OU exclusif) 
convertir en hexadecimal
appliquer OU exclusif caractere par caractere entre les 2 chaines 
a[i] ^ b[i]

test 
    créer une fonction qui convertis en hexa
    verifier les 2 chaines avec la 3eme convertie en hexadecimale
--------------------------------------------------------------------------------------------
                    chal 3

créer une map de rune qui contient toute les lettres d'un livre et qui leur 
incrémente une valeur on la divise par le total de lettres en float64 pour avoir la fréquence
(nb d'occurence par lettre / nb total de lettre)

on donne un "score" au lettres de la map selon leur fréquence

appliquer OU exclusif caractere par caractere entre une chaine et la valeur a 
incrémenter pour tester toute les possibilitées 

a[i] ^ b / a[i] ^ c / a[i] ^ d

scorer / garder le meilleur score (somme des fréquences de chacune des letters dans la chaine) ##1

test
    ecrire la chaine gagnante 
    "Cooking MC's like a pound of bacon" car elle obtient le meilleur score aka la plus grosse 
    somme(cf ##1)

--------------------------------------------------------------------------------------------
                    chal 4

meme opération que le challenge 3 sauf qu'on se rajoute une boucle qui lis dans le fichier 4.txt
on garde la meme source pour le scoring 
il faut que la fonction qui trouve la clef return aussi le score de la chaine gagnante pour continuer 
a scorer avec les chaines suivantes
test
    on print le résultat !! 
    "Now that the party is jumping"

--------------------------------------------------------------------------------------------
                    chal 5

creer une fonction qui XOR "en boucle" une sequence de caractere ICEICEICE sur toute la taille de la chaine
le % est parfait on va xor la chaine avec le caractere i%len(chaine) 012012012 pour une chaine a 3 caracteres
test
    faire matcher la chaine de retour avec la chaine donnée hexdecoded

--------------------------------------------------------------------------------------------
                    chal 6

hamming distance 
Le poids de Hamming correspond au nombre de bits différents de zéro
1011101
1001001
chaine XOR
0010100 hamming distance = 2
peut etre récupéré en golang par la fonction OnesCount8
Donc on va l'utiliser :) 
on compare les 2 chaines (range de s1) si les 2 chaines ne font pas la meme taille cela ne peut pas marcher
et on lance la fonction  OnesCount8 pour savoir le poids de hamming
test   
    tester que notre resultat est de le meme que demandé: 37

créer la fonction qui trouve la taille de la clef grace au poid de hamming 
et répéter la (single)repeatingXORkey
selon la taille du message jouer avec les valeur de findRepeatingXORKeySize and GG